## 寄存器分配

1. 活跃变量分析
2. 图着色 https://juejin.cn/post/6924668410416791566

### 活跃变量分析 (以基本块为单位)

| TAC 代码          | 活跃变量集合    |
| ----------------- | --------------- |
| `_T0 = 4`         | {_T0}           |
| `_T1 = 3`         | {_T0, _T1}      |
| `_T2 = _T0 * _T1` | {_T0}           |
| `_T3 = _T0 * _T0` | {_T0, _T3}      |
| `_T2 = _T3 * _T3` | {_T0, _T2, _T3} |
| `_T2 = _T0 * _T2` | {_T2, _T3}      |
| `_T1 = _T2 * _T3` | {_T1}           |
| `return _T1`      | 空集            |

#### 1. 划分基本块

基本块内的代码执行过程总是从基本块入口开始，到基本块出口结束的，中间不会跳到别的地方或者从别的地方跳进来。

![dataflow](https://tva1.sinaimg.cn/large/008i3skNgy1gyeaakix7uj31c60hb75x.jpg)



#### 2. 以基本块为单位计算 use def

1. Def 集合：一个基本块的 Def 集合是在这个基本块内被定值的所有变量。所谓的定值 （definition），可以理解为给变量赋值，例如加法语句给目标变量定值等（注意：Store 语句不给任何变量定值，Load 语句则会给对应变量定值）。
2. LiveUse 集合：一个基本块的 LiveUse 集合是在这个基本块中所有在定值前就被引用过的变量，包括了在这个基本块中被引用到但是没有被定值的那些变量。

 Def 和 LiveUse 是基本块本身的属性，对每个基本块从后往前遍历基本块内的指令便可以求出。

##### 我们把基本块内所有 TAC 语句分别看成是一个独立的基本块

1. 由于每个结点对应的语句里所引用的所有变量在使用的时候都未在该基本块中经过定值，其 LiveUse 集合就是源操作数对应的所有变量。

#### 3. 以基本块为单位计算 in out

每结束一个基本块检查一次，把 dead 的变量（也就是虚拟寄存器）对应的物理寄存器 put 回栈

### 图着色

用图着色的意义在于：不用计算 in out 了，只要计算每个 tac 的 use